/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2206 from the
 * contents of QRCode.xs. Do not edit this file, edit QRCode.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "src/QRCode.xs"
#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#ifdef __cplusplus
}
#endif

#include "imext.h"
#include "imperl.h"
#include "qrencode.h"

#ifdef UNDER_LIBQRENCODE_1_0_2
QRcode *encode(const char *text,
               int version,
               QRecLevel level,
               QRencodeMode mode,
               int casesensitive)
{
    QRcode *code;

    if(casesensitive) {
        code = QRcode_encodeStringCase(text, version, level);
    } else {
        code = QRcode_encodeString(text, version, level, mode);
    }

    return code;
}
#else
QRcode *encode(const char *text,
               int version,
               QRecLevel level,
               QRencodeMode mode,
               int casesensitive)
{
    QRcode *code = QRcode_encodeString(text, version, level, mode, casesensitive);
    return code;
}

QRcode *encode_8bit(const char *text,
                    int version,
                    QRecLevel level)
{
    QRcode *code = QRcode_encodeString8bit(text, version, level);
    return code;
}
#endif

void generate(i_img *im,
              QRcode *qrcode,
              int size,
              int margin,
              i_color *lightcolor,
              i_color *darkcolor)
{
    unsigned char *p, *q;
    int x, y;
    int base_y;

    /* top margin */
    base_y = 0;
    for(y=base_y; y<base_y+margin; y++) {
        for(x=0; x<qrcode->width + margin * 2; x++) {
            i_box_filled(im,
                         x*size, y*size, x*size + size, y*size + size,
                         lightcolor);
        }
    }

    /* data */
    p = qrcode->data;
    q = p;
    base_y = margin;
    for(y=base_y; y<base_y+qrcode->width; y++) {
        for (x=0; x<margin; x++) {
            i_box_filled(im,
                         x*size, y*size, x*size + size, y*size + size,
                         lightcolor);
        }
        for(x=margin; x<margin + qrcode->width; x++) {
            i_box_filled(im,
                         x*size, y*size, x*size + size, y*size + size,
                         (*q & 1) ? darkcolor : lightcolor);
            q++;
        }
        for (x=margin + qrcode->width; x< qrcode->width + margin * 2; x++) {
            i_box_filled(im,
                         x*size, y*size, x*size + size, y*size + size,
                         lightcolor);
        }
    }

    /* bottom margin */
    base_y = qrcode->width + margin;
    for(y=base_y; y<base_y + margin; y++) {
        for(x=0; x<qrcode->width + margin * 2; x++) {
            i_box_filled(im, x*size, y*size, x*size + size, y*size + size - 1, lightcolor);
        }
    }
}

DEFINE_IMAGER_CALLBACKS;

i_img *_plot(char* text, HV *hv)
{
    i_img* im;
    QRcode *qrcode;
    SV** svp;
    STRLEN len;
    char* ptr;
    int size          = 3;
    int margin        = 4;
    int version       = 0;
    int casesensitive = 0;
    QRencodeMode mode = QR_MODE_8;
    QRecLevel level   = QR_ECLEVEL_L;
    i_color lightcolor, darkcolor;

    if ((svp = hv_fetch(hv, "size", 4, 0)) && *svp && SvOK(*svp)) {
        ptr = SvPV(*svp, len);
        if (ptr >= 0)
            size = atoi(ptr);
    }
    if ((svp = hv_fetch(hv, "margin", 6, 0)) && *svp && SvOK(*svp)) {
        ptr = SvPV(*svp, len);
        if (ptr >= 0)
            margin = atoi(ptr);
    }
    if ((svp = hv_fetch(hv, "level", 5, 0)) && *svp && SvOK(*svp)) {
        ptr = SvPV(*svp, len);
        switch (*ptr) {
        case 'l':
        case 'L':
            level = QR_ECLEVEL_L;
            break;
        case 'm':
        case 'M':
            level = QR_ECLEVEL_M;
            break;
        case 'q':
        case 'Q':
            level = QR_ECLEVEL_Q;
            break;
        case 'h':
        case 'H':
            level = QR_ECLEVEL_H;
            break;
        default:
            level = QR_ECLEVEL_L;
        }
    }
    if ((svp = hv_fetch(hv, "version", 7, 0)) && *svp && SvOK(*svp)) {
        ptr = SvPV(*svp, len);
        if (ptr >= 0)
            version = atoi(ptr);
    }
    if ((svp = hv_fetch(hv, "mode", 4, 0)) && *svp && SvOK(*svp)) {
        ptr = SvPV(*svp, len);
        if (strcmp(ptr, "numerical") == 0) {
            mode = QR_MODE_NUM;
        }
        else if (strcmp(ptr, "alpha-numerical") == 0) {
            mode = QR_MODE_AN;
        }
        else if (strcmp(ptr, "8-bit") == 0) {
            mode = QR_MODE_8;
        }
        else if (strcmp(ptr, "kanji") == 0) {
            mode = QR_MODE_KANJI;
        }
        else {
            croak("Invalid mode: XS error");
        }
    }
    if ((svp = hv_fetch(hv, "casesensitive", 13, 0)) && *svp) {
        casesensitive = SvTRUE(*svp);
    }
    if ((svp = hv_fetch(hv, "lightcolor", 10, 0)) && *svp
        && SvOK(*svp) && sv_derived_from(*svp, "Imager::Color")) {
        lightcolor = *INT2PTR(i_color *, SvIV((SV *)SvRV(*svp)));
    }
    else { /* white */
        lightcolor.rgba.r = 255;
        lightcolor.rgba.g = 255;
        lightcolor.rgba.b = 255;
        lightcolor.rgba.a = 255;
    }
    if ((svp = hv_fetch(hv, "darkcolor", 9, 0)) && *svp && SvOK(*svp)
        && SvOK(*svp) && sv_derived_from(*svp, "Imager::Color")) {
        darkcolor = *INT2PTR(i_color *, SvIV((SV *)SvRV(*svp)));
    }
    else { /* black */
        darkcolor.rgba.r = 0;
        darkcolor.rgba.g = 0;
        darkcolor.rgba.b = 0;
        darkcolor.rgba.a = 255;
    }

#ifdef UNDER_LIBQRENCODE_1_0_2
    qrcode = encode(text, version, level, mode, casesensitive);
#else
    if (mode == QR_MODE_8 || mode == QR_MODE_KANJI)
        qrcode = encode_8bit(text, version, level);
    else
        qrcode = encode(text, version, level, mode, casesensitive);
#endif
    if (qrcode == NULL)
        croak("Failed to encode the input data: XS error");

    im = i_img_16_new(
        (qrcode->width + margin * 2) * size,
        (qrcode->width + margin * 2) * size,
        4
    );
    generate(im, qrcode, size, margin, &lightcolor, &darkcolor);
    QRcode_free(qrcode);

    return im;
}

#line 235 "src/QRCode.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 287 "src/QRCode.c"

XS(XS_Imager__QRCode__plot); /* prototype to pass -Wmissing-prototypes */
XS(XS_Imager__QRCode__plot)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "text, hv");
    {
	char *	text = (char *)SvPV_nolen(ST(0));
	HV *	hv;
	Imager__ImgRaw	RETVAL;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVHV)
	    hv = (HV*)SvRV(ST(1));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Imager::QRCode::_plot",
			"hv");

	RETVAL = _plot(text, hv);
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "Imager::ImgRaw", (void*)RETVAL);

    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Imager__QRCode); /* prototype to pass -Wmissing-prototypes */
XS(boot_Imager__QRCode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Imager::QRCode::_plot", XS_Imager__QRCode__plot, file, "$$");

    /* Initialisation Section */

#line 235 "src/QRCode.xs"
        PERL_INITIALIZE_IMAGER_CALLBACKS;

#line 347 "src/QRCode.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

